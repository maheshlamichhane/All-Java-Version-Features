Modules
-> Modules, introduced in Java 9, provide an extra layer of encapsulation by enabling us to
group related packages.
-> From a high-level, modules enable us to specify well-defined boundries/dependencies in our code
base.
-> As a developer, you can specify which packages are accessible outside the module and also the
module dependencies(the other modules that the module itself depends upon).

-> By default, all classes in the packages in a module are strongly encapsulated i.e no other
module can use these classes, even if they are public classes.

-> Package names and module names live in separate namespaces i.e you can have the same identifiers
without any conflict(name clash).
-> A module contains one or more packages plus a module-info.java file.

-> When compiling a module, it is more convenient to use "module directorries" as otherwise we
would have to list all the .java source files.
-> If you use a module directory, then the name of the module directory must match the name of
the module in the module-info.java file.
-> Place the module-info.java file in the root of the source tree of the module you are
describing.

Why Modules?
-> Improved access control
    * in addition to private, package-private,protected and public now we have the ability to
    restrict packages to certain other packages.
-> Improved large-scale structure of applications.
    * boundries/dependencies in your code base.
    * hide implementation details.
    * improved decoupling.
-> Reduced build sizes:
    * as java itself is now modularized, developers can specify which of the java api modules are
    required for their custom applications; this results in smaller application sizes( a
    consideration for memory-constrained devices);
-> Earlier detection of missing code;
    * prior to modules, missing classes/JAR files might only be realised at runtime, when the
    class/JAR file was being used for the first time.
    * as modules specify their dependencies - in a fully modular environment, the java VM can
    check the whole dependency graph when it starts up; thus, any missing modules would be
    spotted much earlier.

javac -d out src/main/java/module-info.java src/main/java/com/lamichhane/module/ModuleMain.java

java -p out -m TestModuleFarm/com.lamichhane.module.ModuleMain

Dependencies between Modules:
-> As stated earlier by default all classes in the packages in a module are strongly encapsulated
i.e no other module can use these classes,even if they are public classes.
-> If you want a package to be visible outside the module then "export" it in the module-info.java
file. The keyword exports is used.
-> If a module "depends" on another module, the keyword requires is used.
-> All modules implicitly depend on the java.base module.
    * the module exports the java.lang package(String,Object)
-> Remember
    * you export(exports) a package.
    * you depend(requires) on a module

-> The requires keyword between modules forms a dependency graph.
-> lets say farm.stock.sale depends on farm.stock.count
module farm.stock.sale{
    requires farm.stock.count;
}
module.farm.stock.count{
    exports farm.stock.count;
}

opens:
-> Framework such as Spring and Hibernate, frequently require access to our code at runtime via
"reflection".
    - Class.forName("farm.stock.sale.SellThem").newInstance();
-> Via reflection, calling code can override access control and as a result f this power, you must
clearly state that you allow this type of access.
-> Thus we want our type to be strongly encapsulated at compile-time but provide runtime access
via reflection.the keyword opens provides this.
















